{"version":3,"sources":["initialize.js","models/location.js","modules/adder.js","modules/map.js","utils/app-utils.js","utils/utils.js","views/add-view.js","views/search-view.js","views/view.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"uglified.js","sourcesContent":["/* global ko, $ */\nvar app = app || {};\n\n/* This function kicks things off and animate the arrival of locations when\n   the app launches*/\napp.initialize = function () {\n\t'use strict';\n\n\tapp.colors = {\n\t\tblue: '#00A1DE',\n\t\tgreen: '#20603D',\n\t\tyellow: '#FAD201'\n\t};\n\n\tapp.map = app.mapModule();\n\n\t// Used to add locations to the app\n\tapp.adder = app.adderModule();\n\n\t// Locations primarily exist through their names only\n\tapp.hardcodedLocations = [\n\t\t'Lake Kivu', 'Gisenyi', 'Kigali',\n\t\t'Ruhengeri', 'Kigarama', 'Butare', 'Kibungo',\n\t\t'Kinazi', 'Nyungwe Forest National Park'\n\t];\n\tapp.userLocations = $.parseJSON(localStorage.getItem('userLocations')) || [];\n\n\t// Store more elaborate location objects\n\tapp.viewModelLocations = ko.observableArray();\n\n\t// The observable \"treated\" is used to store the number of locations that have been\n\t// treated (failed query or successful build)\n\tapp.hardcodedLocations.treated = ko.observable(0);\n\tapp.hardcodedLocations.treated.subscribe(function (treatedLocations) {\n\t\tif (treatedLocations == app.hardcodedLocations.length) {\n\t\t\tonHardcodedLocationsReady();\n\t\t}\n\t});\n\tapp.adder.addHardcodedLocations(app.hardcodedLocations);\n\n\tif (app.userLocations.length) {\n\t\tapp.userLocations.treated = ko.observable(0);\n\t\t// A delay is necessary to avoid an OverQueryLimit in Google Maps\n\t\twindow.setTimeout(function() {\n\t\t\tapp.adder.addUserLocations(app.userLocations);\n\t\t}, 400);\n\t}\n\n\tapp.viewModel = new app.ViewModel();\n\tko.applyBindings(app.viewModel);\n\n\tfunction onHardcodedLocationsReady () {\n\t\tapp.viewModel.ready(true);\n\t\tdropHardcodedLocations();\n\t}\n\n\tfunction dropHardcodedLocations () {\n\t\tapp.viewModel.searchVM.hardcodedLocations().forEach(function (location) {\n\t\t\tlocation.marker.setMap(app.map);\n\t\t});\n\t\tapp.viewModel.openSearchBar();\n\t\tapp.viewModel.message('My gorillas!', 2000, function () {\n\t\t\tapp.viewModel.hide();\n\t\t\tif (app.userLocations.length > 0) {\n\t\t\t\tcheckUserLocations();\n\t\t\t}\n\t\t});\n\t}\n\n\t// If all user locations are already treated they are dropped, otherwise a subscription\n\t// is made to the number of treated locations\n\tfunction checkUserLocations () {\n\t\tif (app.userLocations.treated() == app.userLocations.length) {\n\t\t\tdropUserLocations();\n\t\t} else {\n\t\t\tapp.userLocations.treated.subscribe(function (treatedLocations) {\n\t\t\t\tif (treatedLocations == app.userLocations.length) {\n\t\t\t\t\tdropUserLocations();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction dropUserLocations () {\n\t\tapp.viewModel.searchVM.userLocations().forEach(function (location) {\n\t\t\tlocation.marker.setMap(app.map);\n\t\t});\n\t\tapp.viewModel.openAddBar();\n\t\tapp.viewModel.message('And your sugar canes!', 2000, function () {\n\t\t\tapp.viewModel.hide();\n\t\t});\n\t}\n};","/* global google.maps, $, _, ko */\nvar app = app || {};\n\n/* This class is used to build location objects if a successful google text\n  search query occured. Each instance is stored in app.viewModelLocations */\napp.ViewModelLocation = function (locationDetails) {\n\t'use strict';\n\n\tthis.name = locationDetails.name;\n\n\tthis.position = locationDetails.geometry.location;\n\t// The bounds of the map are updated ech time a location is added\n\tapp.map.updateBoundsWithPosition(this.position);\n\n\tthis.isHardcoded = app.isHardcoded(this.name);\n\n\t// Used when searching the locations to highlight the first match\n\tthis.highlighted = ko.observable(false);\n\n\t// An image is served for each hardcoded location\n\tif (this.isHardcoded) {\n\t\tthis.url = 'img/' + this.name.toLowerCase().replace(/ /g,\"-\") + '.jpg';\n\t} else {\n\t\tthis.url = \"\";\n\t}\n\n\tthis.buildMarker();\n\n\t// The content of the infoWindow is completed after querying Wikipedia\n\tthis.infoWindow = new google.maps.InfoWindow({\n\t\tmaxWidth: 280\n\t});\n\tthis.queryWikipedia();\n};\n\napp.ViewModelLocation.prototype.toggle = function () {\n\tif (this.marker.getAnimation() !== null) {\n\t\tthis.close();\n\t} else {\n\t\tapp.viewModel.closeAll();\n\t\tthis.open();\n\t}\n};\n\napp.ViewModelLocation.prototype.close = function () {\n\tif (this.marker.getAnimation() !== null) {\n\t\tthis.marker.setAnimation(null);\n\t\tthis.infoWindow.close();\n\t}\n};\n\napp.ViewModelLocation.prototype.open = function () {\n\tthis.marker.setAnimation(google.maps.Animation.BOUNCE);\n\tthis.infoWindow.open(app.map, this.marker);\n\t// Explicitly set the wikipedia link that for some reason doesn't work otherwise\n\t$(\".wiki-link\").click(function () {\n\t\tif (this.href) {\n\t\t\twindow.open(this.href);\n\t\t}\n\t});\n};\n\napp.ViewModelLocation.prototype.buildMarker = function () {\n\t// Create the marker without assigning it to the map\n\tthis.marker = new google.maps.Marker({\n\t\tposition: this.position,\n\t\ticon: this.isHardcoded ? 'img/gorilla-pin.png' : 'img/sugar-cane-pin.png',\n\t\tanimation: google.maps.Animation.DROP\n\t});\n\n\tthis.marker.addListener('click', function () {\n\t\tapp.viewModel.hide();\n\t\tthis.toggle()\n\t}.bind(this))\n};\n\napp.ViewModelLocation.prototype.queryWikipedia = function () {\n\tvar baseUrl = 'https://en.wikipedia.org/w/api.php?action=opensearch&search=',\n\t\trequestUrl = baseUrl + this.name + '&format=json';\n\n\t$.ajax({\n\t\turl: requestUrl,\n\t\tdataType: \"jsonp\",\n\t\tjsonp: \"callback\",\n\t\tsuccess: onSuccess.bind(this),\n\t\terror: onError.bind(this)\n\t});\n\n\tfunction onSuccess (response) {\n\t\tvar description = response[2][0],\n\t\t\turl = response[3][0];\n\n\t\tvar wikipediaData = {\n\t\t\tdescription: description,\n\t\t\turl: url\n\t\t}\n\n\t\tthis.setInfoWindow(wikipediaData);\n\t\tif (!app.viewModel.ready())\n\t\t\tapp.oneLocationTreated(this.isHardcoded);\n\t}\n\n\tfunction onError () {\n\t\tthis.setInfoWindow();\n\t\tif (!app.viewModel.ready())\n\t\t\tapp.oneLocationTreated(this.isHardcoded);\n\t}\n};\n\napp.ViewModelLocation.prototype.setInfoWindow = function (wikipediaData) {\n\tthis.infoWindow.addListener('closeclick', this.close.bind(this));\n\n\tvar $infoWindowHtml = $(this.infoWindowTemplate(this));\n\n\tif (!this.isHardcoded) {\n\t\t$infoWindowHtml.children('img').remove();\n\t}\n\n\tif (wikipediaData) {\n\t\tvar description = wikipediaData.description,\n\t\t\turl = wikipediaData.url;\n\t}\n\n\t// In case the wikipedia page obtained is a disambiguation page (containing 'may refer'),\n\t// the description is not included in the infowindow and only a link is provided\n\tif (description && description.length > 0 && !description.match(/may refer/)) {\n\t\t$infoWindowHtml.children('.wiki-description').text(description);\n\t} else {\n\t\t$infoWindowHtml.children('.wiki-description').remove();\n\t}\n\n\tif (url) {\n\t\t$infoWindowHtml.children('.wiki-link').attr('href', url);\n\t} else {\n\t\t$infoWindowHtml.children('.wiki-link').remove();\n\t}\n\n\tthis.infoWindow.setContent($infoWindowHtml.outerHtml());\n};\n\n// Underscore.js is used to create a templating function for the info window\napp.ViewModelLocation.prototype.infoWindowTemplate = _.template($('#infowindow-template').html());","/* global google.maps */\nvar app = app || {};\n\n/* This object hides the complexity of turning location names into location\n   objects */\napp.adderModule = function () {\n\t'use strict';\n\n\t// Location details are queried via Google TextSearch\n\tvar service = new google.maps.places.PlacesService(app.map);\n\n\tfunction queryLocationsAllAtOnce (locations) {\n\t\tlocations.forEach(function (location) {\n\t\t\tqueryLocation(location, addStoredLocation, onStoredLocationError);\n\t\t});\n\t}\n\n\t// After the first 10 queries, a delay is needed between each query\n\t// to avoid a Google Maps OverQueryLimit\n\tfunction queryLocationsOneByOne (locations, index) {\n\t\tvar index = index || 0;\n\t\tif (index < locations.length) {\n\t\t\tqueryLocation(locations[index], addStoredLocation, onStoredLocationError);\n\t\t\twindow.setTimeout(function () {\n\t\t\t\tqueryLocationsOneByOne(locations, index + 1);\n\t\t\t}, 500)\n\t\t}\n\t}\n\n\tfunction queryNewLocation (location) {\n\t\tqueryLocation(location, addNewLocation, onNewLocationError);\n\t}\n\n\t// The callback functions are different depending on if the location was\n\t// already stored or not\n\tfunction queryLocation(location, onSuccess, onError) {\n\t\tvar request = { query: location + ' Rwanda'};\n\n\t\tservice.textSearch(request, function (results, status) {\n\t\t\tconsole.log(status);\n\t\t\tif (status == google.maps.places.PlacesServiceStatus.OK) {\n\t\t\t\tonSuccess(results);\n\t\t\t} else {\n\t\t\t\tonError(location);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction addStoredLocation (results) {\n\t\tvar locationDetails = results[0];\n\t\tapp.viewModelLocations.push(new app.ViewModelLocation(locationDetails));\n\t}\n\n\tfunction addNewLocation (results) {\n\t\tvar locationDetails = results[0],\n\t\t\tlocationName = locationDetails.name;\n\n\t\tif (app.hasLocation(locationName)) {\n\t\t\tapp.viewModel.message('Already occupied!');\n\n\t\t} else {\n\t\t\tstoreNewLocation(locationName);\n\n\t\t\tvar newLocation = new app.ViewModelLocation(locationDetails);\n\t\t\tdropNewLocation(newLocation);\n\t\t\tapp.viewModelLocations.push(newLocation);\n\t\t}\n\t}\n\n\tfunction dropNewLocation (newLocation) {\n\t\tnewLocation.marker.setMap(app.map);\n\t\tapp.viewModel.message('A new sugar cane!');\n\t}\n\n\tfunction storeNewLocation (locationName) {\n\t\tapp.userLocations.push(locationName);\n\t\tlocalStorage.setItem('userLocations', JSON.stringify(app.userLocations));\n\t}\n\n\tfunction onStoredLocationError (locationName) {\n\t\tvar isHardcoded = app.isHardcoded(locationName);\n\t\tapp.oneLocationTreated();\n\t}\n\n\tfunction onNewLocationError () {\n\t\tapp.viewModel.message('Not found in Rwanda!');\n\t}\n\n\treturn {\n\t\taddHardcodedLocations: queryLocationsAllAtOnce,\n\t\taddUserLocations: queryLocationsOneByOne,\n\t\taddNewLocation: queryNewLocation\n\t};\n}","/* global google.maps */\nvar app = app || {};\n\n/* This object provides a simple interface to interact with the\n   google map */\napp.mapModule = function () {\n\t'use strict';\n\n\tvar rwanda = new google.maps.LatLng(-1.930820, 29.874024);\n\tvar options = {\n\t\tcenter: rwanda,\n\t\tzoom: 9,\n\t\tdisableDefaultUI: true,\n\t\tstyles: [\n\t\t\t{\n\t\t\t\t\"featureType\": \"road.highway\",\n\t\t\t\t\"stylers\": [\n\t\t\t\t\t{ \"visibility\": \"off\" }\n\t\t\t\t]\n\t\t\t},{\n\t\t\t\t\"featureType\": \"administrative.country\",\n\t\t\t\t\"elementType\": \"geometry.stroke\",\n\t\t\t\t\"stylers\": [\n\t\t\t\t\t{ \"color\": app.colors.yellow }\n\t\t\t\t]\n\t\t\t}\n\t\t]\n\t};\n\n\tvar map = new google.maps.Map(document.getElementById('map'), options);\n\tvar bounds = new google.maps.LatLngBounds();\n\n\tmap.updateBoundsWithPosition = function (position) {\n\t\tbounds.extend(position);\n\t\tmap.fitBounds(bounds);\n\t};\n\n\tmap.panToPosition = function (position) {\n\t\tmap.panTo(position);\n\t};\n\n\t// These clicks are not triggered when clicking on a gorilla\n\tmap.addListener('click', function () {\n\t\tapp.viewModel.closeAll();\n\t});\n\n\treturn map;\n};","/* global */\nvar app = app || {};\n\n(function () {\n\t'use strict';\n\n\tapp.isHardcoded = function (locationName) {\n\t\tfor (var l=0, len=app.hardcodedLocations.length; l<len; l++) {\n\t\t\tif (app.hardcodedLocations[l] == locationName)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tapp.hasLocation = function (locationName) {\n\t\tif (app.isHardcoded(locationName)) return true;\n\t\tfor (var l=0, len=app.userLocations.length; l<len; l++) {\n\t\t\tif (app.userLocations[l] == locationName)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tapp.oneLocationTreated = function (isHardcoded) {\n\t\tif (isHardcoded) {\n\t\t\tvar locationsTreated = app.hardcodedLocations.treated();\n\t\t\tapp.hardcodedLocations.treated(locationsTreated + 1);\n\t\t} else {\n\t\t\tvar locationsTreated = app.userLocations.treated();\n\t\t\tapp.userLocations.treated(locationsTreated + 1);\n\t\t}\n\t};\n})();","/* global ko, $ */\n\n// Helper functions\n(function () {\n\t'use strict';\n\n\tjQuery.fn.outerHtml = function () {\n\t\treturn jQuery('<div />').append(this.eq(0).clone()).html();\n\t};\n\n\t/* Binding handler factory taken from the TODOMVC project: http://todomvc.com/ */\n\tvar ENTER_KEY = 13;\n\tvar ESCAPE_KEY = 27;\n\tvar UP_ARROW = 38;\n\tvar DOWN_ARROW = 40;\n\n\t// A factory function we can use to create binding handlers for specific\n\t// keycodes.\n\tfunction keyhandlerBindingFactory(keyCode) {\n\t\treturn {\n\t\t\tinit: function (element, valueAccessor, allBindingsAccessor, data, bindingContext) {\n\t\t\t\tvar wrappedHandler, newValueAccessor;\n\n\t\t\t\t// wrap the handler with a check for the enter key\n\t\t\t\twrappedHandler = function (data, event) {\n\t\t\t\t\tif (event.keyCode === keyCode) {\n\t\t\t\t\t\tvalueAccessor().call(this, data, event);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// create a valueAccessor with the options that we would want to pass to the event binding\n\t\t\t\tnewValueAccessor = function () {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tkeyup: wrappedHandler\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// call the real event binding's init function\n\t\t\t\tko.bindingHandlers.event.init(element, newValueAccessor, allBindingsAccessor, data, bindingContext);\n\t\t\t}\n\t\t};\n\t}\n\n\tko.bindingHandlers.enterKey = keyhandlerBindingFactory(ENTER_KEY);\n\tko.bindingHandlers.escapeKey = keyhandlerBindingFactory(ESCAPE_KEY);\n\tko.bindingHandlers.upArrow = keyhandlerBindingFactory(UP_ARROW);\n\tko.bindingHandlers.downArrow = keyhandlerBindingFactory(DOWN_ARROW);\n\n\t// Keep the input bar focused when changing the showMode\n\tko.bindingHandlers.keepFocus = {\n\t    update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n\t        var focused = ko.unwrap(valueAccessor());\n\t        var showMode = bindingContext.$root.searchVM.showMode();\n\t        if (focused) $(element).focus();\n\t    }\n\t};\n})();","/* global ko */\nvar app = app || {};\n\n/* The add view model is responsible for the input bar when the user is\n   adding a location */\napp.AddViewModel = function (viewModel) {\n\t'use strict';\n\n\tthis.inputText = viewModel.inputText;\n\n\tthis.bar = ko.observable(false);\n\tvar addMessage = 'Add a new place !';\n\n\tthis.active = ko.computed(function() {\n\t\tvar bar = this.bar(),\n\t\t\tinputText = this.inputText();\n\t\treturn bar && !(inputText == addMessage);\n\t}.bind(this));\n\n\t// Toggle add bar or add a new location\n\tthis.onButtonClick = function () {\n\t\tif (!this.active()) {\n\t\t\tif (this.bar()) {\n\t\t\t\tapp.viewModel.hide();\n\t\t\t} else {\n\t\t\t\tapp.viewModel.openAddBar();\n\t\t\t\tapp.viewModel.inputText(addMessage);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.add();\n\t\t}\n\t}.bind(this);\n\n\tthis.add = function () {\n\t\tvar inputText = this.inputText();\n\t\tif (inputText.length <= 1) {\n\t\t\tapp.viewModel.message('Type a location to add!');\n\t\t} else {\n\t\t\tapp.adder.addNewLocation(inputText);\n\t\t}\n\t};\n};","/* global ko */\nvar app = app || {};\n\n/* The search view model is responsible for displaying the list of locations\n   and responding to user inputs related to searching and selecting a location */\napp.SearchViewModel = function (viewModel) {\n\t'use strict';\n\n\tthis.locations = viewModel.locations;\n\tthis.inputText = viewModel.inputText;\n\tthis.messaging = viewModel.messaging;\n\n\tthis.hardcodedLocations = ko.computed(function () {\n\t\treturn this.locations().filter(function (location) {\n\t\t\treturn location.isHardcoded;\n\t\t});\n\t}.bind(this));\n\n\tthis.userLocations = ko.computed(function () {\n\t\treturn this.locations().filter(function (location) {\n\t\t\treturn !location.isHardcoded;\n\t\t});\n\t}.bind(this));\n\n\t// The bar observable control the visibility and style of the input bar\n\tthis.bar = ko.observable(false);\n\tvar searchMessage = 'Search places in Rwanda';\n\n\tthis.showMode = ko.observable('hardcoded');\n\n\t// The active observable controls the visibility of the list view\n\tthis.active = ko.computed(function() {\n\t\tvar bar = this.bar(),\n\t\t\tinputText = this.inputText(),\n\t\t\tmessaging = this.messaging();\n\t\treturn bar && !(inputText == searchMessage) && !messaging;\n\t}.bind(this));\n\n\t// Toggle search bar\n\tthis.onButtonClick = function () {\n\t\tif (this.bar()) {\n\t\t\tapp.viewModel.hide();\n\t\t} else {\n\t\t\tapp.viewModel.openSearchBar();\n\t\t\tthis.inputText(searchMessage);\n\t\t}\n\t}.bind(this);\n\n\tthis.filterGorillas = function () {\n\t\tif (this.showMode() != 'hardcoded') {\n\t\t\t// The search field is reset when changing the filter\n\t\t\tthis.inputText('');\n\t\t\tthis.showMode('hardcoded');\n\t\t}\n\t}.bind(this);\n\n\tthis.filterSugarCanes = function () {\n\t\tif (this.showMode() != 'user') {\n\t\t\tthis.inputText('');\n\t\t\tthis.showMode('user');\n\t\t}\n\t}.bind(this);\n\n\tthis.filteredLocations = ko.computed(function() {\n\t\tvar showMode = this.showMode();\n\t\treturn showMode == 'hardcoded' ? this.hardcodedLocations : this.userLocations;\n\t}.bind(this));\n\n\tthis.matchingLocations = ko.computed(function () {\n\t\tvar inputText = this.inputText(),\n\t\t\tactive = this.active(),\n\t\t\tlocations = this.locations(),\n\t\t\tfilteredLocations = this.filteredLocations()();\n\n\t\tif (!active) {\n\t\t\t// All locations are visible\n\t\t\tlocations.forEach(function (location) {\n\t\t\t\tlocation.marker.setVisible(true)\n\t\t\t});\n\t\t\treturn locations;\n\n\t\t} else if (inputText == '') {\n\t\t\t// Only sugar canes or gorillas are visible\n\t\t\tlocations.forEach(function (location) {\n\t\t\t\tlocation.marker.setVisible(false)\n\t\t\t});\n\t\t\tfilteredLocations.forEach(function (location) {\n\t\t\t\tlocation.marker.setVisible(true);\n\t\t\t});\n\t\t\tif (filteredLocations.length) {\n\t\t\t\tthis.highlight(filteredLocations[0]);\n\t\t\t}\n\t\t\treturn filteredLocations;\n\n\t\t} else {\n\t\t\t// Only matching sugar canes or gorillas are visible\n\t\t\tinputText = inputText.toLowerCase().trim();\n\t\t\tvar matchingLocations = filteredLocations.filter(function (location) {\n\t\t\t\t// The text typed by the user will match if it is found anywhere\n\t\t\t\t// in a location name\n\t\t\t\tvar regex = new RegExp('.*' + inputText + '.*'),\n\t\t\t\t\tmatching = regex.test(location.name.toLowerCase());\n\n\t\t\t\tlocation.marker.setVisible(matching);\n\t\t\t\treturn matching;\n\t\t\t});\n\t\t\tif (matchingLocations.length) {\n\t\t\t\tthis.highlight(matchingLocations[0])\n\t\t\t}\n\t\t\treturn matchingLocations;\n\t\t}\n\t}.bind(this));\n\n\tthis.highlight = function (location) {\n\t\tthis.locations().forEach(function (location) {\n\t\t\tlocation.highlighted(false);\n\t\t});\n\t\tlocation.highlighted(true);\n\t}.bind(this);\n\n\t// On down arrow\n\tthis.highlightNext = function () {\n\t\tvar matchingLocations = this.matchingLocations();\n\t\tfor (var i=0, len=matchingLocations.length - 1; i<len; i++) {\n\t\t\tif (matchingLocations[i].highlighted()) {\n\t\t\t\tthis.highlight(matchingLocations[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t// On up arrow\n\tthis.highlightPrevious = function () {\n\t\tvar matchingLocations = this.matchingLocations();\n\t\tfor (var i=1, len=matchingLocations.length; i<len; i++) {\n\t\t\tif (matchingLocations[i].highlighted()) {\n\t\t\t\tthis.highlight(matchingLocations[i-1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t// On enter key or list-item click\n\tthis.panToAndOpen = function () {\n\t\tvar location = this.highlightedLocation();\n\t\tif (location) {\n\t\t\tapp.viewModel.hide();\n\t\t\tlocation.toggle();\n\t\t\tapp.map.panToPosition(location.position);\n\t\t} else {\n\t\t\tapp.viewModel.message('Not in stock sorry!');\n\t\t}\n\t}.bind(this);\n\n\tthis.highlightedLocation = ko.computed(function() {\n\t\tvar matchingLocations = this.matchingLocations();\n\t\tfor (var i=0, len=matchingLocations.length; i<len; i++) {\n\t\t\tif (matchingLocations[i].highlighted()) {\n\t\t\t\treturn matchingLocations[i];\n\t\t\t}\n\t\t}\n\t}.bind(this));\n}","/* global ko */\nvar app = app || {};\n\n/* The main view model contains two sub-view models, correponding to the two main\n   functionalities of the app: searching a location and adding a location.\n   The main view model handles the input bar in the middle and how it is shared by\n   the two functionalities */\napp.ViewModel = function () {\n\t'use strict';\n\n\tthis.locations = app.viewModelLocations;\n\n\tthis.inputText = ko.observable('');\n\n\tthis.messaging = ko.observable(false);\n\n\tthis.searchVM = new app.SearchViewModel(this);\n\n\tthis.addVM = new app.AddViewModel(this);\n\n\tthis.ready = ko.observable(false);\n\n\tthis.message = function (message, duration, callback) {\n\t\tvar duration = duration || 1500;\n\t\tvar callback = callback || function() {}\n\t\tthis.messaging(true);\n\t\tthis.inputText(message);\n\t\twindow.setTimeout(function() {\n\t\t\tthis.inputText('');\n\t\t\tthis.messaging(false);\n\t\t\tcallback();\n\t\t}.bind(this), duration)\n\t};\n\n\tthis.click = function () {\n\t\tthis.inputText('');\n\t\tapp.viewModel.closeAll();\n\t}.bind(this);\n\n\tthis.hide = function () {\n\t\tthis.searchVM.bar(false);\n\t\tthis.addVM.bar(false);\n\t};\n\n\tthis.onEnterKey = function () {\n\t\tif (this.searchVM.bar()) {\n\t\t\tthis.searchVM.panToAndOpen();\n\t\t} else if (this.addVM.bar()) {\n\t\t\tthis.addVM.add();\n\t\t}\n\t};\n\n\tthis.onDownArrow = function () {\n\t\tif (this.searchVM.bar()) {\n\t\t\tthis.searchVM.highlightNext();\n\t\t}\n\t};\n\n\tthis.onUpArrow = function () {\n\t\tif (this.searchVM.bar()) {\n\t\t\tthis.searchVM.highlightPrevious();\n\t\t}\n\t};\n\n\tthis.closeAll = function () {\n\t\tthis.locations().forEach(function (location) {\n\t\t\tlocation.close();\n\t\t});\n\t};\n\n\tthis.openSearchBar = function () {\n\t\tthis.addVM.bar(false);\n\t\tthis.searchVM.bar(true);\n\t};\n\n\tthis.openAddBar = function () {\n\t\tthis.searchVM.bar(false);\n\t\tthis.addVM.bar(true);\n\t};\n};"],"sourceRoot":"/source/"}